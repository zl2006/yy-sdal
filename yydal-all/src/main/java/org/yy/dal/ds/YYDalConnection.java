package org.yy.dal.ds;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.sql.DataSource;

import org.apache.commons.beanutils.BeanUtils;
import org.yy.dal.ds.constants.ConnectionStatus;
import org.yy.dal.ds.holder.ConnectionHolder;
import org.yy.dal.ds.support.YYDalConnectionSupport;

import com.mchange.v2.c3p0.ComboPooledDataSource;

/**
 * 分库分表数据库连接,不支持的操作见YYDalConnectionNotSupport
 * 
 * @author  zhouliang
 * @version  [1.0, 2016年2月17日]
 * @since  [yy-sdal/1.0]
 */
public class YYDalConnection extends YYDalConnectionSupport implements Connection {
    
    /**
     * 数据源
     */
    private YYDalDatasource datasource;
    
    /**
     * 连接关闭
     */
    private boolean close = false;
    
    /**
     * 连接状态
     */
    private ConnectionStatus status = new ConnectionStatus();
    
    /**
     * 放置数据库实例连接：针对每个实例最多一个连接, key值为实例下标
     */
    private Map<String, ConnectionHolder> connection = new HashMap<String, ConnectionHolder>();
    
    public YYDalConnection(YYDalDatasource dataSource) {
        this.datasource = dataSource;
    }
    
    @Override
    public void setAutoCommit(boolean autoCommit)
        throws SQLException {
        for (String key : connection.keySet()) {
            connection.get(key).setAutoCommit(autoCommit);
        }
        status.setAutoCommit(autoCommit);
    }
    
    @Override
    public boolean getAutoCommit()
        throws SQLException {
        return status.isAutoCommit();
    }
    
    /** {@inheritDoc} */
    @Override
    public void setSchema(String schema)
        throws SQLException {
        for (String key : connection.keySet()) {
            connection.get(key).setSchema(schema);
        }
        status.setSchema(schema);
    }
    
    /** {@inheritDoc} */
    @Override
    public String getSchema()
        throws SQLException {
        return status.getSchema();
    }
    
    @Override
    public void commit()
        throws SQLException {
        for (String key : connection.keySet()) {
            connection.get(key).commit();
        }
    }
    
    @Override
    public void rollback()
        throws SQLException {
        for (String key : connection.keySet()) {
            connection.get(key).rollback();
        }
    }
    
    @Override
    public void close()
        throws SQLException {
        for (String key : connection.keySet()) {
            connection.get(key).close();
        }
        this.close = true;
    }
    
    @Override
    public boolean isClosed()
        throws SQLException {
        return this.close;
    }
    
    @Override
    public void setReadOnly(boolean readOnly)
        throws SQLException {
        for (String key : connection.keySet()) {
            connection.get(key).setReadOnly(readOnly);
        }
        status.setReadOnly(readOnly);
    }
    
    @Override
    public boolean isReadOnly()
        throws SQLException {
        return status.isReadOnly();
    }
    
    @Override
    public void setCatalog(String catalog)
        throws SQLException {
        for (String key : connection.keySet()) {
            connection.get(key).setCatalog(catalog);
        }
        status.setCatalog(catalog);
    }
    
    @Override
    public String getCatalog()
        throws SQLException {
        return status.getCatalog();
    }
    
    @Override
    public void setTransactionIsolation(int level)
        throws SQLException {
        for (String key : connection.keySet()) {
            connection.get(key).setTransactionIsolation(level);
        }
        status.setTransactionIsolation(level);
    }
    
    @Override
    public int getTransactionIsolation()
        throws SQLException {
        return status.getTransactionIsolation();
    }
    
    @Override
    public YYDalPreparedStatement prepareStatement(String sql)
        throws SQLException {
        return new YYDalPreparedStatement(datasource, this, sql);
    }
    
    @Override
    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency)
        throws SQLException {
        return new YYDalPreparedStatement(datasource, this, sql, resultSetType, resultSetConcurrency);
    }
    
    @Override
    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency,
        int resultSetHoldability)
        throws SQLException {
        return new YYDalPreparedStatement(datasource, this, sql, resultSetType, resultSetConcurrency,
            resultSetHoldability);
    }
    
    @Override
    public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys)
        throws SQLException {
        return new YYDalPreparedStatement(datasource, this, sql, autoGeneratedKeys);
    }
    
    @Override
    public PreparedStatement prepareStatement(String sql, int[] columnIndexes)
        throws SQLException {
        return new YYDalPreparedStatement(datasource, this, sql, columnIndexes);
    }
    
    @Override
    public PreparedStatement prepareStatement(String sql, String[] columnNames)
        throws SQLException {
        return new YYDalPreparedStatement(datasource, this, sql, columnNames);
    }
    
    @Override
    public void setHoldability(int holdability)
        throws SQLException {
        for (String key : connection.keySet()) {
            connection.get(key).setHoldability(holdability);
        }
        status.setHoldability(holdability);
    }
    
    @Override
    public int getHoldability()
        throws SQLException {
        return status.getHoldability();
    }
    
    public YYDalDatasource getDatasource() {
        return datasource;
    }
    
    public ConnectionHolder get(String instNumber) {
        return connection.get(instNumber);
    }
    
    public void put(String instNumber, ConnectionHolder conn) {
        if (connection.get(instNumber) == null) {
            connection.put(instNumber, conn);
        }
    }
    
    @SuppressWarnings("unchecked")
    @Override
    public <T> T unwrap(Class<T> iface)
        throws SQLException {
        if (iface == null) {
            return null;
        }
        
        if (iface.isInstance(this)) {
            return (T)this;
        }
        
        return null;
    }
    
    @Override
    public boolean isWrapperFor(Class<?> iface)
        throws SQLException {
        return iface != null && iface.isInstance(this);
    }
    
    @Override
    public SQLWarning getWarnings()
        throws SQLException {
        for (String key : connection.keySet()) {
            return connection.get(key).getWarnings();
        }
        return null;
    }
    
    @Override
    public void clearWarnings()
        throws SQLException {
        for (String key : connection.keySet()) {
            connection.get(key).clearWarnings();
        }
    }
    
    /**
    * @return 返回 status
    */
    public ConnectionStatus getStatus() {
        return status;
    }
    
    public static void main(String[] args)
        throws Exception {
        Map<String, String> testMap = new HashMap<String, String>();
        testMap.put("driverClass", "com.mysql.jdbc.Driver");
        testMap.put("jdbcUrl", "jdbc:mysql://localhost:3306/useradmin_inst?useUnicode=true&characterEncoding=UTF8");
        testMap.put("user", "root");
        testMap.put("password", "root");
        testMap.put("minPoolSize", "15");
        testMap.put("acquireIncrement", "8");
        testMap.put("maxPoolSize", "35");
        testMap.put("maxIdleTime", "160");
        
        List<String> tableDescs = new ArrayList<String>();
        tableDescs.add("user_[8]:hash(user_id)");
        tableDescs.add("qrcode_[8]:customFunc(qrcode_str)");
        tableDescs.add("TB_WLJ_QRCODE_[1]:hash(QRCODE)");
        
        com.mchange.v2.c3p0.ComboPooledDataSource defaultDs = new ComboPooledDataSource();
        BeanUtils.populate(defaultDs, testMap);
        DataSource ds =
            new YYDalDatasource(defaultDs, testMap, "com.mchange.v2.c3p0.ComboPooledDataSource", "c3p0", "mysql",
                "jdbc:mysql://127.0.0.1:3306/useradmin_inst_[1-4]", tableDescs);
        
        Connection connection = ds.getConnection();
        PreparedStatement ps =
            connection.prepareStatement("SELECT * FROM TB_WLJ_QRCODE a WHERE a.QRCODE='aaa' and TEST < 'cc' or DD > 'cc'  and BB <= 123 and abs(aa)=bb(cc)");
        ps.executeQuery();
        ps = connection.prepareStatement("SELECT * FROM TB_WLJ_QRCODE a1, TTTT a2");
        ps.executeQuery();
        ps = connection.prepareStatement("UPDATE TB_WLJ_QRCODE a set a.TIMES=a.TIMES+1 WHERE a.QRCODE='bbb'");
        ps.executeUpdate();
        ps = connection.prepareStatement("UPDATE TB_WLJ_QRCODE set TIMES=TIMES+1");
        ps.executeUpdate();
        ps = connection.prepareStatement("INSERT TB_WLJ_QRCODE(QRCODE,ID) VALUES('ccc',123)");
        ps.execute();
        ps = connection.prepareStatement("INSERT TB_WLJ_QRCODE(QRCODE) VALUES( abs('ccc') )");
        ps.execute();
        ps = connection.prepareStatement("DELETE TB_WLJ_QRCODE");
        ps.execute();
        ps = connection.prepareStatement("DELETE TB_WLJ_QRCODE a WHERE a.QRCODE='ddd'");
        ps.execute();
        //ResultSet rs = ps.executeQuery();
        
    }
    
}
